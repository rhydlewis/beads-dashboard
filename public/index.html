<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beads Continuous Flow Dashboard</title>
    <script
      src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.js"></script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        background-color: #f8fafc;
        font-family: ui-sans-serif, system-ui, sans-serif;
      }
      .card {
        background: white;
        border-radius: 0.75rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        padding: 1.25rem;
        border: 1px solid #e2e8f0;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- Load Components -->
    <script type="text/babel" src="components/DashboardView.js"></script>
    <script type="text/babel" src="components/TableView.js"></script>

    <!-- Main Application -->
    <script type="text/babel">
      function Dashboard() {
        const [parsedIssues, setParsedIssues] = React.useState([]);
        const [loading, setLoading] = React.useState(true);
        const [error, setError] = React.useState(null);
        const [activeTab, setActiveTab] = React.useState("table");

        const fetchData = async () => {
          try {
            const res = await fetch("/api/data");
            if (!res.ok) throw new Error("Failed to fetch data");
            const data = await res.json();
            setParsedIssues(data);
            setLoading(false);
            setError(null);
          } catch (err) {
            console.error(err);
            setError(err.message);
            setLoading(false);
          }
        };

        React.useEffect(() => {
          fetchData();

          const socket = io();
          socket.on("refresh", () => {
            console.log("Data changed, reloading...");
            fetchData();
          });

          return () => socket.disconnect();
        }, []);

        const metrics = React.useMemo(() => {
          if (!parsedIssues.length) return null;

          const activeIssues = parsedIssues.filter(i => i.status !== 'tombstone');
          const today = new Date();
          const openIssues = activeIssues.filter((i) => i.status !== "closed");
          const closedIssues = activeIssues.filter((i) => i.status === "closed" && i.updated_at);

          // 1. Organize activity by date
          const activityByDate = {};
          let earliestDate = new Date();

          activeIssues.forEach((i) => {
            const cDateStr = i.created_at.split("T")[0];
            const cDate = new Date(cDateStr);
            if (cDate < earliestDate) earliestDate = cDate;

            if (!activityByDate[cDateStr])
              activityByDate[cDateStr] = { created: 0, closed: 0 };
            activityByDate[cDateStr].created++;

            if (i.status === "closed" && i.updated_at) {
              const clDateStr = i.updated_at.split("T")[0];
              if (!activityByDate[clDateStr])
                activityByDate[clDateStr] = { created: 0, closed: 0 };
              activityByDate[clDateStr].closed++;
            }
          });

          // 2. Continuous Timeline Filling
          const flowChartData = [];
          let runCreated = 0;
          let runClosed = 0;

          let iterDate = new Date(earliestDate);
          while (iterDate <= today) {
            const dateStr = iterDate.toISOString().split("T")[0];
            const dayActivity = activityByDate[dateStr] || {
              created: 0,
              closed: 0,
            };

            runCreated += dayActivity.created;
            runClosed += dayActivity.closed;

            flowChartData.push({
              date: dateStr,
              open: runCreated - runClosed,
              closed: runClosed,
              throughput: dayActivity.closed,
            });

            iterDate.setDate(iterDate.getDate() + 1);
          }

          // 3. Work Item Age Calculation
          let totalAge = 0;
          const ageBuckets = { "0-7d": 0, "8-14d": 0, "15-30d": 0, "30d+": 0 };
          const agingWipData = [];

          openIssues.forEach((i) => {
            const ageInDays = Math.floor(
              (today - new Date(i.created_at)) / (1000 * 60 * 60 * 24),
            );
            totalAge += ageInDays;
            if (ageInDays <= 7) ageBuckets["0-7d"]++;
            else if (ageInDays <= 14) ageBuckets["8-14d"]++;
            else if (ageInDays <= 30) ageBuckets["15-30d"]++;
            else ageBuckets["30d+"]++;

            agingWipData.push({
              id: i.id || "Unknown",
              status: i.status || "Open",
              age: ageInDays,
              title: i.title || i.id || "Issue",
            });
          });

          // 4. Lead Time Calculation
          const leadTimeData = closedIssues.map((i) => {
            const created = new Date(i.created_at);
            const closed = new Date(i.updated_at);
            const cycleTime = Math.max(
              0,
              Math.ceil((closed - created) / (1000 * 60 * 60 * 24))
            );
            return {
              id: i.id || "Unknown",
              closedDate: closed.getTime(), // Numeric for scatter X axis
              closedDateStr: i.updated_at.split("T")[0],
              cycleTime,
              title: i.title || i.id || "Issue",
            };
          }).sort((a, b) => a.closedDate - b.closedDate);

          // Calculate Percentiles
          const sortedCycles = leadTimeData.map(d => d.cycleTime).sort((a, b) => a - b);
          const p50 = sortedCycles.length ? sortedCycles[Math.floor(sortedCycles.length * 0.5)] : 0;
          const p85 = sortedCycles.length ? sortedCycles[Math.floor(sortedCycles.length * 0.85)] : 0;

          // Color code Aging WIP
          const coloredAgingWipData = agingWipData.map(d => ({
            ...d,
            color: d.age <= 7 ? "#10b981" : d.age <= 30 ? "#f59e0b" : "#ef4444"
          }));

          return {
            avgAge: openIssues.length
              ? (totalAge / openIssues.length).toFixed(1)
              : 0,
            ageChartData: Object.entries(ageBuckets).map(([range, count]) => ({
              range,
              count,
            })),
            flowChartData,
            openCount: openIssues.length,
            agingWipData: coloredAgingWipData,
            leadTimeData,
            cycleTimeP50: p50,
            cycleTimeP85: p85,
          };
        }, [parsedIssues]);

        const projectName = React.useMemo(() => {
          if (!parsedIssues.length) return "";
          // Attempt to extract project prefix from the first issue ID (e.g. beads-dashboard-123 -> beads-dashboard)
          const firstId = parsedIssues[0].id;
          const lastDashIndex = firstId.lastIndexOf('-');
          if (lastDashIndex > 0) {
             return firstId.substring(0, lastDashIndex);
          }
          return "";
        }, [parsedIssues]);

        return (
          <div className="max-w-8xl mx-auto p-8">
            <header className="mb-8">
              <div className="flex justify-between items-center mb-6">
                <div>
                    <h1 className="text-2xl font-bold text-slate-900">
                    {projectName && <span className="text-slate-500 font-normal">{projectName} / </span>}
                    Beads Performance Dashboard
                    </h1>
                    <p className="text-slate-500 text-sm">
                    Live View â€¢ {parsedIssues.filter(i => i.status !== 'tombstone').length} issues loaded
                    </p>
                </div>
                <div className="text-xs text-slate-400">
                    {loading ? "Connecting..." : "Connected"}
                </div>
              </div>

              {/* Tabs */}
              <div className="flex space-x-4 border-b border-slate-200">
                <button
                    className={`pb-2 px-1 text-sm font-medium ${
                        activeTab === "table"
                            ? "border-b-2 border-blue-500 text-blue-600"
                            : "text-slate-500 hover:text-slate-700"
                    }`}
                    onClick={() => setActiveTab("table")}
                >
                    All Issues
                </button>
                <button
                  className={`pb-2 px-1 text-sm font-medium ${
                    activeTab === "dashboard"
                      ? "border-b-2 border-blue-500 text-blue-600"
                      : "text-slate-500 hover:text-slate-700"
                  }`}
                  onClick={() => setActiveTab("dashboard")}
                >
                  Dashboard
                </button>
              </div>
            </header>

            {loading && !parsedIssues.length ? (
               <div className="card py-20 text-center text-slate-400">
                 Loading data...
               </div>
            ) : error ? (
               <div className="card py-20 text-center text-red-500">
                 {error}
               </div>
            ) : !metrics ? (
              <div className="card border-dashed border-2 py-20 text-center text-slate-400">
                No issues found in .beads directory.
              </div>
            ) : activeTab === "table" ? (
                <TableView issues={parsedIssues} />
            ) : (
                <DashboardView metrics={metrics} />
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<Dashboard />);
    </script>
  </body>
</html>
